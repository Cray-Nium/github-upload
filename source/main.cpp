/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/* 
 * File:   main.cpp
 * Author: NEON
 *
 * Created on July 31, 2018, 7:15 PM
 */

//Passwords - pi: radhazard, root: neontiger
//Core monitor: htop
//Apt-get installs:
//  mpg123
//  libmpg123-dev
//  libout123-dev
//  lirc
//  liblircclient-dev
//Lirc files:
//  /etc/lirc/mPi3_config.lircrc - written
//  /etc/lirc/lircd.conf - generated by irrecord
//Music stored at /home/pi/Music/mPi3_library
//int and long are both 4 bytes

#include <cstdlib>
#include <stdio.h>
#include <iostream>
#include <pthread.h>
//#include <strings.h> //This was in basic mpg123 example, but didn't break the build when removed

//Testing Sigil
//#include "sl.h"


/*
//For file searching
//#include <sys/types.h>
#include <dirent.h>
#include <errno.h>
#include <vector>
#include <cstring>
#include <string>
#include <algorithm> //To get sort()
*/

//My files
#include "globals.h"
#include "audioPlayback.h"
#include "irControl.h"
#include "gui.h"


using namespace std;

bool mPi3ShuttingDown = false;

pthread_t audioThread;
pthread_t irControlThread; //Must be a different thread because it blocks
pthread_t guiThread;

bool init();
void cleanup();


int main() {

    if (!init()) return -99;

    //When the order was gui - audio - ir, the ir control wasn't working. Try to figure out why. -> Seemed gui was a processor hog when not frame rate limited. Turning on vsync fixed the problem.
    
    if(pthread_create(&guiThread, NULL, guiThreadRun, NULL))
    {
        fprintf(stderr, "Error creating gui thread\n");
        return 1;
    }
    
    if(pthread_create(&audioThread, NULL, audioThreadRun, NULL))
    {
        fprintf(stderr, "Error creating audioPlayback thread\n");
        return 1;
    }

    if(pthread_create(&irControlThread, NULL, irThreadRun, NULL))
    {
        fprintf(stderr, "Error creating irControl thread\n");
        return 1;
    }

    //Running...
   
    if(pthread_join(audioThread, NULL)) 
    {
        fprintf(stderr, "Error joining audioPlayback thread\n");
        return 2;
    }
    
    pthread_cancel(irControlThread);
    
    cleanup();

    return 0;
}

void cleanup()
{
    irControlCleanup();
    audioPlaybackCleanup();
    guiCleanup();
}

bool init()
{
    bool retVal = true;

    if (!audioPlaybackInit()){
        cout << "Problem with audioPlaybackInit." << endl;
        retVal = false;
    }

    if (!irControlInit()){
        cout << "Problem with irControlInit." << endl;
        retVal = false;
    }

    if (!guiInit()){
        cout << "Problem with guiInit." << endl;
        retVal = false;
    }
    
    return retVal;
}


//////////////////////////////////FOR REFERENCE/////////////////////////////////
/*

//FORMAT CODES
enum mpg123_enc_enum
{
0000 0000 0000 1111 Some 8 bit integer encoding.
 MPG123_ENC_8 = 0x00f
// 0000 0000 0100 0000 Some 16 bit integer encoding.
, MPG123_ENC_16 = 0x040
// 0100 0000 0000 0000 Some 24 bit integer encoding.
, MPG123_ENC_24 = 0x4000
// 0000 0001 0000 0000 Some 32 bit integer encoding.
, MPG123_ENC_32 = 0x100
// 0000 0000 1000 0000 Some signed integer encoding.
, MPG123_ENC_SIGNED = 0x080
// 0000 1110 0000 0000 Some float encoding.
, MPG123_ENC_FLOAT = 0xe00
// 0000 0000 1101 0000 signed 16 bit
, MPG123_ENC_SIGNED_16 = (MPG123_ENC_16|MPG123_ENC_SIGNED|0x10)
// 0000 0000 0110 0000 unsigned 16 bit
, MPG123_ENC_UNSIGNED_16 = (MPG123_ENC_16|0x20)
// 0000 0000 0000 0001 unsigned 8 bit 
, MPG123_ENC_UNSIGNED_8 = 0x01
// 0000 0000 1000 0010 signed 8 bit 
, MPG123_ENC_SIGNED_8 = (MPG123_ENC_SIGNED|0x02)
// 0000 0000 0000 0100 ulaw 8 bit 
, MPG123_ENC_ULAW_8 = 0x04
// 0000 0000 0000 1000 alaw 8 bit 
, MPG123_ENC_ALAW_8 = 0x08
// 0001 0001 1000 0000 signed 32 bit
, MPG123_ENC_SIGNED_32 = MPG123_ENC_32|MPG123_ENC_SIGNED|0x1000
// 0010 0001 0000 0000 unsigned 32 bit
, MPG123_ENC_UNSIGNED_32 = MPG123_ENC_32|0x2000
// 0101 0000 1000 0000 signed 24 bit
, MPG123_ENC_SIGNED_24 = MPG123_ENC_24|MPG123_ENC_SIGNED|0x1000
// 0110 0000 0000 0000 unsigned 24 bit
, MPG123_ENC_UNSIGNED_24 = MPG123_ENC_24|0x2000
// 0000 0010 0000 0000 32bit float
, MPG123_ENC_FLOAT_32 = 0x200
// 0000 0100 0000 0000 64bit float
, MPG123_ENC_FLOAT_64 = 0x400
// Any possibly known encoding from the list above.
, MPG123_ENC_ANY = ( MPG123_ENC_SIGNED_16 | MPG123_ENC_UNSIGNED_16
 | MPG123_ENC_UNSIGNED_8 | MPG123_ENC_SIGNED_8
 | MPG123_ENC_ULAW_8 | MPG123_ENC_ALAW_8
 | MPG123_ENC_SIGNED_32 | MPG123_ENC_UNSIGNED_32
 | MPG123_ENC_SIGNED_24 | MPG123_ENC_UNSIGNED_24
 | MPG123_ENC_FLOAT_32 | MPG123_ENC_FLOAT_64 )
};
*/ 
